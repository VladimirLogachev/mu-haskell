<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>Mu-Haskell: Schemas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mu is a purely functional library for building microservices.">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="/mu-haskell/wip/img/poster.png" />
    <meta property="og:title" content="Mu-Haskell: Schemas" />
    <meta property="og:site_name" content="Mu-Haskell: Schemas" />
    <meta property="og:url" content="https://higherkindess.io/mu-haskell" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Mu is a purely functional library for building microservices." />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Mu is a purely functional library for building microservices." />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@47deg">
    <meta name="twitter:creator" content="@47deg">
    <meta name="twitter:image" content="/mu-haskell/wip/img/poster.png" />

    <meta property="github-info" data-github-owner="higherkindness" data-github-repo="mu-haskell" />

    <script defer src="/mu-haskell/wip/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/mu-haskell/wip/img/favicon.png">

    <!-- mu-haskell docs css -->
    <link rel="stylesheet" type="text/css" href="/mu-haskell/wip/css/docs.css">
</head>

    <body>
        <div id="site-sidebar">
  <div class="sidebar-brand">
    <a href="/mu-haskell/wip/" class="brand" title="Mu-Haskell">
      <img
        src="/mu-haskell/wip/img/nav-brand-white.svg"
        alt="Mu-Haskell"
        class="brand-wrapper"
      />
      <span>Mu-Haskell</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/wip/"
        class=""
        title="Start"
      >
        Start
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/wip/intro/"
        class=""
        title="Introduction"
      >
        Introduction
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item active open">
       
      <a
        href="/mu-haskell/wip/schema/"
        title="Schemas"
        class="drop-nested"
      >
        Schemas
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/registry/"
          title="Registry"
        >
          Registry
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <a
        href="/mu-haskell/wip/rpc/"
        title="Services and servers"
        class="drop-nested"
      >
        Services and servers
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/grpc/"
          title="gRPC"
        >
          gRPC
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/stream/"
          title="Streams"
        >
          Streams
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/db/"
          title="Databases"
        >
          Databases
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Integrations"
        class="button drop-nested"
      >
        Integrations
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/transformer/"
          title="Transformers"
        >
          Transformers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/middleware/"
          title="Middleware"
        >
          Middleware
        </a>
        
      </div>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/mu-haskell/wip/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        <div class="link-item">
          <a class="strong" href="/mu-haskell/wip/haddock/" title="API Docs" target="_blank" rel="noopener noreferrer">API Docs</a>
        </div>
        <div class="link-item">
          <a href="https://github.com/higherkindness/mu-haskell" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="schemas">Schemas</h1>

<p>Using <code class="highlighter-rouge">mu-schema</code> you can describe a schema for your data using type-level techniques. You can then automatically generate:</p>

<ul>
  <li>conversion between your Haskell data types and the values as expected by the schema,</li>
  <li>serialization to <a href="https://avro.apache.org/">Avro</a>, <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>, and <a href="https://www.json.org/">JSON</a>.</li>
</ul>

<p>Since <code class="highlighter-rouge">mu-schema</code> makes heavy use of type-level techniques, you need to open up the Pandoraâ€™s box by enabling (at least) the following extensions: <code class="highlighter-rouge">PolyKinds</code> and <code class="highlighter-rouge">DataKinds</code>.</p>

<h2 id="records-and-enumerations">Records and enumerations</h2>

<p>Here is a simple schema which defines the schema types <code class="highlighter-rouge">gender</code>, <code class="highlighter-rouge">address</code>, and <code class="highlighter-rouge">person</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language PolyKinds, DataKinds #-}</span>

<span class="kr">import</span> <span class="nn">Mu.Schema</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>

<span class="kr">type</span> <span class="kt">ExampleSchema</span>
  <span class="o">=</span> <span class="sc">'[</span><span class="err"> </span><span class="kt">'DEnum</span>   <span class="s">"gender"</span>
                <span class="sc">'[</span><span class="err"> </span><span class="kt">'ChoiceDef</span> <span class="s">"male"</span>
                 <span class="p">,</span> <span class="kt">'ChoiceDef</span> <span class="s">"female"</span>
                 <span class="p">,</span> <span class="kt">'ChoiceDef</span> <span class="s">"nb"</span> <span class="p">]</span>
     <span class="p">,</span> <span class="kt">'DRecord</span> <span class="s">"address"</span>
               <span class="sc">'[</span><span class="err"> </span><span class="kt">'FieldDef</span> <span class="s">"postcode"</span> <span class="p">(</span><span class="kt">'TPrimitive</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span><span class="p">)</span>
                <span class="p">,</span> <span class="kt">'FieldDef</span> <span class="s">"country"</span>  <span class="p">(</span><span class="kt">'TPrimitive</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span><span class="p">)</span> <span class="p">]</span>
     <span class="p">,</span> <span class="kt">'DRecord</span> <span class="s">"person"</span>
                <span class="sc">'[</span><span class="err"> </span><span class="kt">'FieldDef</span> <span class="s">"firstName"</span> <span class="p">(</span><span class="kt">'TPrimitive</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span><span class="p">)</span>
                 <span class="p">,</span> <span class="kt">'FieldDef</span> <span class="s">"lastName"</span>  <span class="p">(</span><span class="kt">'TPrimitive</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span><span class="p">)</span>
                 <span class="p">,</span> <span class="kt">'FieldDef</span> <span class="s">"age"</span>       <span class="p">(</span><span class="kt">'TOption</span> <span class="p">(</span><span class="kt">'TPrimitive</span> <span class="kt">Int</span><span class="p">))</span>
                 <span class="p">,</span> <span class="kt">'FieldDef</span> <span class="s">"gender"</span>    <span class="p">(</span><span class="kt">'TOption</span> <span class="p">(</span><span class="kt">'TSchematic</span> <span class="s">"gender"</span><span class="p">))</span>
                 <span class="p">,</span> <span class="kt">'FieldDef</span> <span class="s">"address"</span>   <span class="p">(</span><span class="kt">'TSchematic</span> <span class="s">"address"</span><span class="p">)</span> <span class="p">]</span>
     <span class="p">]</span>
</code></pre></div></div>

<p>As you can see, a <em>schema</em> is just a list of schema types. Each of these types has a <em>name</em> and can either be an enumeration or a record.</p>

<ul>
  <li>An <em>enumeration</em> defines a set of values that the type can take,</li>
  <li>A <em>record</em> contains a list of <em>fields</em>, each of them with a name and a <em>field type</em>. The allowed types for the fields are:
    <ul>
      <li><code class="highlighter-rouge">TPrimitive</code> for primitive types such as <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Bool</code>. Note that if you want to have a string you should <em>not</em> use the <code class="highlighter-rouge">String</code> from <code class="highlighter-rouge">Prelude</code>, but rather <code class="highlighter-rouge">Text</code> from <code class="highlighter-rouge">Data.Text</code>.</li>
      <li><code class="highlighter-rouge">TSchematic</code> to reference another type <em>in the same schema</em> by name.</li>
      <li><code class="highlighter-rouge">TOption</code>, <code class="highlighter-rouge">TList</code>, <code class="highlighter-rouge">TMap</code>, and <code class="highlighter-rouge">TUnion</code> are combinators for the field types.</li>
    </ul>
  </li>
</ul>

<p>Note that GHC requires all of <code class="highlighter-rouge">DEnum</code>, <code class="highlighter-rouge">DRecord</code>, <code class="highlighter-rouge">FieldDef</code>, and so forth to be prefixed by a quote sign <code class="highlighter-rouge">'</code>. This declares that we are working with <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion">promoted types</a> (you do not have to understand what a promoted type is, but you need to remember to use the quote sign).</p>

<h3 id="defining-a-schema-using-protocol-buffers">Defining a schema using Protocol Buffers</h3>

<p>As discussed in the introduction, <code class="highlighter-rouge">mu-schema</code> has been developed with some common schema formats in mind. Instead of writing the type-level schemas by hand, you can also import your <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a> schemas.</p>

<p>The idea is that your schema lives in an external file, so you can share it with other components of your system. To declare that we want the file to be pre-processed before compilation, we use a GHC feature called <code class="highlighter-rouge">TemplateHaskell</code>, hence the initial line starting with <code class="highlighter-rouge">language</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language TemplateHaskell #-}</span>

<span class="kr">import</span> <span class="nn">Mu.Quasi.ProtoBuf</span>

<span class="n">protobuf</span> <span class="s">"ExampleSchema"</span> <span class="s">"path/to/file.proto"</span>
</code></pre></div></div>

<p>That single line asks the compiler to generate a <code class="highlighter-rouge">ExampleSchema</code> type which represents the schema from the given file. In addition, it also generates a mapping from fields to identifiers, as described below.</p>

<p>One word of warning: GHC reads the contents of the file <em>in order</em>, resolving <code class="highlighter-rouge">TemplateHaskell</code> blocks when found. Only then the results are visible to the rest of the file. In particular, the <code class="highlighter-rouge">protobuf</code> line should appear <em>before</em> any other code mentioning the <code class="highlighter-rouge">ExampleSchema</code> type.</p>

<h3 id="schemas-part-of-services">Schemas part of services</h3>

<p>If you use the <code class="highlighter-rouge">grpc</code> function to import a gRPC <code class="highlighter-rouge">.proto</code> file in the type-level, that function already takes care of creating an appropiate schema for <em>all</em> the messages. If you prefer to have different schemas for different subsets of messages (for example, aggregated by services), you can either:</p>

<ul>
  <li>Write the schemas by hand,</li>
  <li>Split the definition file into several ones, and import each of them in its own <code class="highlighter-rouge">protobuf</code> block.</li>
</ul>

<h2 id="mapping-haskell-types">Mapping Haskell types</h2>

<p>These schemas become more useful once you can map your Haskell types to them. <code class="highlighter-rouge">mu-schema</code> uses the generics mechanism built in GHC to automatically derive these mappings, asuming that you declare your data types using field names.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances #-}</span>
<span class="cp">{-# language DeriveGeneric, DeriveAnyClass #-}</span>

<span class="kr">import</span> <span class="nn">GHC.Generics</span>

<span class="kr">data</span> <span class="kt">Address</span>
  <span class="o">=</span> <span class="kt">Address</span> <span class="p">{</span> <span class="n">postcode</span> <span class="o">::</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span>
            <span class="p">,</span> <span class="n">country</span>  <span class="o">::</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">ToSchema</span>   <span class="kt">Maybe</span> <span class="kt">ExampleSchema</span> <span class="s">"address"</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">FromSchema</span> <span class="kt">Maybe</span> <span class="kt">ExampleSchema</span> <span class="s">"address"</span><span class="p">)</span>
</code></pre></div></div>

<p>Once again, you need to enable some extensions in the compiler (but do not worry, GHC should tell you which ones you need in case you forgot). You first must include <code class="highlighter-rouge">Generic</code> in the list of automatically-derived classes. Then you <em>derive</em> the mapping by using the lines:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">ToSchema</span>   <span class="kt">Maybe</span> <span class="kt">YourSchema</span> <span class="s">"yourSchemaType"</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">FromSchema</span> <span class="kt">Maybe</span> <span class="kt">YourSchema</span> <span class="s">"yourSchemaType"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="customizing-the-mapping">Customizing the mapping</h2>

<p>Sometimes the names of the fields in the Haskell data type and the names of the fields in the schema do not match. For example, in our schema above we use <code class="highlighter-rouge">male</code>, <code class="highlighter-rouge">female</code>, and <code class="highlighter-rouge">nb</code>, but in a Haskell enumeration the name of each constructor must begin with a capital letter. By using a standalone <code class="highlighter-rouge">ToSchema</code> instance you can declare a custom mapping from Haskell fields or constructors to schema fields or enum choices, respectively:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language DerivingVia  #-}</span>
<span class="cp">{-# language TypeFamilies #-}</span>

<span class="kr">type</span> <span class="kt">GenderFieldMapping</span>
  <span class="o">=</span> <span class="sc">'[</span><span class="err"> </span><span class="s">"Male"</span>      <span class="sc">':</span><span class="err">-</span><span class="o">&gt;</span> <span class="s">"male"</span>
     <span class="p">,</span> <span class="s">"Female"</span>    <span class="sc">':</span><span class="err">-</span><span class="o">&gt;</span> <span class="s">"female"</span>
     <span class="p">,</span> <span class="s">"NonBinary"</span> <span class="sc">':</span><span class="err">-</span><span class="o">&gt;</span> <span class="s">"nb"</span> <span class="p">]</span>

<span class="kr">data</span> <span class="kt">Gender</span> <span class="o">=</span> <span class="kt">Male</span> <span class="o">|</span><span class="err">Â </span><span class="kt">Female</span> <span class="o">|</span> <span class="kt">NonBinary</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">ToSchema</span> <span class="n">f</span> <span class="kt">ExampleSchema</span> <span class="s">"gender"</span><span class="p">,</span> <span class="kt">FromSchema</span> <span class="n">f</span> <span class="kt">ExampleSchema</span> <span class="s">"gender"</span><span class="p">)</span>
    <span class="n">via</span> <span class="p">(</span><span class="kt">CustomFieldMapping</span> <span class="s">"gender"</span> <span class="kt">GenderFieldMapping</span> <span class="kt">Gender</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="protocol-buffers-field-identifiers">Protocol Buffers field identifiers</h3>

<p>If you want to use (de)serialization to Protocol Buffers, you need to declare one more piece of information. A Protocol Buffer record or enumeration assigns both names and <em>numeric identifiers</em> to each field or value, respectively. If you use <code class="highlighter-rouge">protobuf</code> or <code class="highlighter-rouge">grpc</code> to import your Protocol Buffers schemas, this is done automatically for you.</p>

<p><code class="highlighter-rouge">mu-schema</code> supports extending the information of a schema by means of <em>annotations</em>. Annotations are linked to both a certain format (<code class="highlighter-rouge">ProtoBufAnnotation</code> in this case) and a certain schema. Furthermore, annotations may range over the whole schema, a specific record or enumeration, or a specific field or choice. In the case of Protocol Buffers, we only need the latter:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language TypeFamilies #-}</span>

<span class="kr">import</span> <span class="nn">Mu.Adapter.ProtoBuf</span>

<span class="kr">type</span> <span class="kr">instance</span> <span class="kt">AnnotatedSchema</span> <span class="kt">ProtoBufAnnotation</span> <span class="kt">ExampleSchema</span>
  <span class="o">=</span> <span class="sc">'[</span><span class="err"> </span><span class="o">...</span>
     <span class="p">,</span> <span class="kt">'AnnField</span> <span class="s">"address"</span> <span class="s">"postcode"</span> <span class="p">(</span><span class="kt">'ProtoBufId</span> <span class="mi">1</span><span class="p">)</span>
     <span class="p">,</span> <span class="kt">'AnnField</span> <span class="s">"address"</span> <span class="s">"country "</span> <span class="p">(</span><span class="kt">'ProtoBufId</span> <span class="mi">2</span><span class="p">)</span>
     <span class="p">,</span> <span class="o">...</span> <span class="p">]</span>
</code></pre></div></div>

    </div>
</main>

    </body>
</html>
